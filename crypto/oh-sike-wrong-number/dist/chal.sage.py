

# This file was *autogenerated* from the file /home/supasuge/Projects/HackDearbornCTF-2024-Private/crypto/oh-sike-wrong-number/dist/chal.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_32 = Integer(32); _sage_const_3 = Integer(3); _sage_const_20 = Integer(20); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_8 = Integer(8); _sage_const_0xFF = Integer(0xFF)
import random
from sage.all import *

# SIDH parameters (simplified for demonstration)
p = _sage_const_2 **_sage_const_32  * _sage_const_3 **_sage_const_20  - _sage_const_1   # A small prime for quick computation
eA, eB = _sage_const_32 , _sage_const_20 

import random
from sage.all import *

# SIDH parameters (simplified for demonstration)
p = _sage_const_2 **_sage_const_32  * _sage_const_3 **_sage_const_20  - _sage_const_1   # A small prime for quick computation
eA, eB = _sage_const_32 , _sage_const_20 

def keygen():
    # Generate base curve
    Fp2 = GF(p**_sage_const_2 , 'i', modulus=x**_sage_const_2 +_sage_const_1 )
    E0 = EllipticCurve(Fp2, [_sage_const_0 ,_sage_const_6 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ])  # y^2 = x^3 + 6x^2 + x
    
    # Generate torsion bases
    xP2, xQ2 = E0.division_points(_sage_const_2 **eA, _sage_const_2 )
    xP3, xQ3 = E0.division_points(_sage_const_3 **eB, _sage_const_2 )
    
    # Bob's secret and public key
    secret_key = random.randint(_sage_const_0 , _sage_const_3 **eB - _sage_const_1 )
    phi = E0.isogeny((xP3 + secret_key * xQ3), _sage_const_3 **eB)
    EB = phi.codomain()
    xPB = phi(xP2)
    xQB = phi(xQ2)
    
    return E0, xP2, xQ2, xP3, xQ3, EB, xPB, xQB, secret_key

def encrypt_flag(flag, shared_secret):
    key = int(shared_secret.xy()[_sage_const_0 ])
    return bytes([c ** ((key >> (_sage_const_8 *i)) & _sage_const_0xFF ) for i, c in enumerate(flag)])

# Generate keys
E0, xP2, xQ2, xP3, xQ3, EB, xPB, xQB, secret_key = keygen()

# Encrypt flag
flag = b'hctf3{exexwxe}'
shared_secret = E0.isogeny((xP2 + secret_key * xQ2), _sage_const_2 **eA).codomain().j_invariant()
encrypted_flag = encrypt_flag(flag, shared_secret)

print(f"p = {p}")
print(f"E0: {E0}")
print(f"xP2 = {xP2}")
print(f"xQ2 = {xQ2}")
print(f"xP3 = {xP3}")
print(f"xQ3 = {xQ3}")
print(f"EB: {EB}")
print(f"xPB = {xPB}")
print(f"xQB = {xQB}")
print(f"Encrypted flag: {encrypted_flag.hex()}")

